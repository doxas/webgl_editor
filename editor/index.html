<!DOCTYPE html>
<html><head>
	<meta charset="UTF-8">
	<meta name="description" content="webgl editor">
	<meta name="keywords" content="webgl editor">
	<link rel="stylesheet" href="style.css" type="text/css">
	<script type="text/javascript" src="minMatrix.js"></script>
	<script type="text/javascript" src="script.js"></script>
	<script src="src-noconflict/ace.js" type="text/javascript"></script>
	<script src="src-noconflict/ext-searchbox.js" type="text/javascript"></script>
	<title>webgl editor</title>
</head>
<body>
	<div id="left">
		<iframe id="frame"></iframe>
		<div id="console">
			<p>webgl editor</p>
		</div>
	</div>
	<div id="right">
		<div id="tabs">
			<div id="tabJavascript" class="tab active">javascript</div>
			<div id="tabHTML" class="tab">html</div>
			<div id="tabVertex" class="tab">vertex shader</div>
			<div id="tabFragment" class="tab">fragment shader</div>
		</div>
		<pre id="editorJavascript" class="editor selected">// canvasエレメントを取得
var c = document.getElementById('canvas');

// canvasのサイズをスクリーン全体に広げる
c.width = 512;
c.height = 512;

// webglコンテキストを取得
var gl = c.getContext('webgl') || c.getContext('experimental-webgl');

// 頂点シェーダとフラグメントシェーダの生成
var vShader = create_shader(WE.vs, gl.VERTEX_SHADER);
var fShader = create_shader(WE.fs, gl.FRAGMENT_SHADER);

// プログラムオブジェクトの生成とリンク
var prg = create_program(vShader, fShader);

// attributeLocationの取得
var attLocation = gl.getAttribLocation(prg, 'position');

// attributeの要素数(この場合は xyz の3要素)
var attStride = 3;

// モデル(頂点)データ
var vPosition = [
	 0.0, 1.0, 0.0,
	 1.0, 0.0, 0.0,
	-1.0, 0.0, 0.0
];

// VBOの生成
var vbo = create_vbo(vPosition);

// VBOをバインド
gl.bindBuffer(gl.ARRAY_BUFFER, vbo);

// attribute属性を有効にする
gl.enableVertexAttribArray(attLocation);

// attribute属性を登録
gl.vertexAttribPointer(attLocation, attStride, gl.FLOAT, false, 0, 0);

// minMatrix.js を用いた行列関連処理
// matIVオブジェクトを生成
var m = new WE.parent.matIV();

// 各種行列の生成と初期化
var mMatrix = m.identity(m.create());
var vMatrix = m.identity(m.create());
var pMatrix = m.identity(m.create());
var vpMatrix = m.identity(m.create());
var mvpMatrix = m.identity(m.create());

// canvasを初期化する色を設定する
gl.clearColor(0.0, 0.0, 0.0, 1.0);

// canvasを初期化する際の深度を設定する
gl.clearDepth(1.0);

// canvasを初期化
gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

// ビュー座標変換行列
m.lookAt([0.0, 0.0, 3.0], [0.0, 0.0, 0.0], [0.0, 1.0, 0.0], vMatrix);

// プロジェクション座標変換行列
m.perspective(45, c.width / c.height, 0.1, 10.0, pMatrix);

// 各行列を掛け合わせ座標変換行列を完成させる
m.multiply(pMatrix, vMatrix, vpMatrix);
m.multiply(vpMatrix, mMatrix, mvpMatrix);

// uniformLocationの取得
var uniLocation = gl.getUniformLocation(prg, 'mvpMatrix');

// uniformLocationへ座標変換行列を登録
gl.uniformMatrix4fv(uniLocation, false, mvpMatrix);

// モデルの描画
gl.drawArrays(gl.TRIANGLES, 0, 3);

// コンテキストの再描画
gl.flush();

/**
 * シェーダを生成する関数
 * @param {string} source シェーダのソースとなるテキスト
 * @param {number} type シェーダのタイプを表す定数 gl.VERTEX_SHADER or gl.FRAGMENT_SHADER
 * @return {object} 生成に成功した場合はシェーダオブジェクト、失敗した場合は null
 */
function create_shader(source, type){
	// シェーダを格納する変数
	var shader;
	
	// シェーダの生成
	shader = gl.createShader(type);
	
	// 生成されたシェーダにソースを割り当てる
	gl.shaderSource(shader, source);
	
	// シェーダをコンパイルする
	gl.compileShader(shader);
	
	// シェーダが正しくコンパイルされたかチェック
	if(gl.getShaderParameter(shader, gl.COMPILE_STATUS)){
		
		// 成功していたらシェーダを返して終了
		return shader;
	}else{
		
		// 失敗していたらエラーログをアラートする
		alert(gl.getShaderInfoLog(shader));
		
		// null を返して終了
		return null;
	}
}

/**
 * プログラムオブジェクトを生成しシェーダをリンクする関数
 * @param {object} vs 頂点シェーダとして生成したシェーダオブジェクト
 * @param {object} fs フラグメントシェーダとして生成したシェーダオブジェクト
 * @return {object} 生成に成功した場合はプログラムオブジェクト、失敗した場合は null
 */
function create_program(vs, fs){
	// プログラムオブジェクトの生成
	var program = gl.createProgram();
	
	// プログラムオブジェクトにシェーダを割り当てる
	gl.attachShader(program, vs);
	gl.attachShader(program, fs);
	
	// シェーダをリンク
	gl.linkProgram(program);
	
	// シェーダのリンクが正しく行なわれたかチェック
	if(gl.getProgramParameter(program, gl.LINK_STATUS)){
	
		// 成功していたらプログラムオブジェクトを有効にする
		gl.useProgram(program);
		
		// プログラムオブジェクトを返して終了
		return program;
	}else{
		
		// 失敗していたらエラーログをアラートする
		alert(gl.getProgramInfoLog(program));
		
		// null を返して終了
		return null;
	}
}

/**
 * VBOを生成する関数
 * @param {Array.<number>} data 頂点属性を格納した一次元配列
 * @return {object} 頂点バッファオブジェクト
 */
function create_vbo(data){
	// バッファオブジェクトの生成
	var vbo = gl.createBuffer();
	
	// バッファをバインドする
	gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
	
	// バッファにデータをセット
	gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW);
	
	// バッファのバインドを無効化
	gl.bindBuffer(gl.ARRAY_BUFFER, null);
	
	// 生成した VBO を返して終了
	return vbo;
}</pre>
		<pre id="editorHTML" class="editor">&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;style&gt;
			* {
				margin: 0px;
				padding: 0px;
				overflow: hidden;
			}
			html, body{
				width: 100%;
				height: 100%;
			}
		&lt;/style&gt;
	&lt;/head&gt;
	&lt;body&gt;
		&lt;canvas id="canvas"&gt;&lt;/canvas&gt;
	&lt;/body&gt;
&lt;/html&gt;</pre>
		<pre id="editorVertex" class="editor">attribute vec3 position;
uniform   mat4 mvpMatrix;

void main(){
	gl_Position = mvpMatrix * vec4(position, 1.0);
}</pre>
		<pre id="editorFragment" class="editor">precision mediump float;
void main(){
	gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);
}</pre>
		<div id="menu">
			<div>
				<p>
					<span class="caption">append function:</span>
					<select id="appendFunction">
						<option value="">select function</option>
						<option value="all_function">all function</option>
						<option value="create_shader">create_shader</option>
						<option value="create_program">create_program</option>
						<option value="create_vbo">create_vbo</option>
						<option value="create_ibo">create_ibo</option>
						<option value="set_attribute">set_attribute</option>
						<option value="create_texture">create_texture</option>
						<option value="create_framebuffer">create_framebuffer</option>
						<option value="create_texture_cube">create_texture_cube</option>
						<option value="create_framebuffer_cube">create_framebuffer_cube</option>
					</select>
					<input id="appendButton" type="button" value="append">
				</p>
			</div>
			<div>
				<p>
					<input id="runButton" type="button" value=" run ">
					<input id="stopButton" type="button" value=" stop ">
				</p>
			</div>
		</div>
	</div>
</body></html>


